"""
Gestionnaire d'interface graphique pour NiTrite v.2
VERSION COMPL√àTE - Affiche TOUS les programmes disponibles (80+)
MODE SOMBRE √©l√©gant
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
import json
from pathlib import Path
from datetime import datetime
import logging
import webbrowser
import subprocess
import win32com.client
import winshell

class NiTriteGUIComplet:
    """Interface graphique compl√®te affichant TOUS les programmes"""
    
    # Couleurs du th√®me sombre
    DARK_BG = '#1e1e1e'          # Fond principal
    DARK_BG2 = '#252526'         # Fond secondaire
    DARK_BG3 = '#2d2d30'         # Fond tertiaire
    DARK_FG = '#d4d4d4'          # Texte principal
    DARK_FG2 = '#969696'         # Texte secondaire
    ACCENT_BLUE = '#007acc'      # Accent bleu
    ACCENT_GREEN = '#4ec9b0'     # Accent vert
    ACCENT_ORANGE = '#ce9178'    # Accent orange
    ACCENT_RED = '#f48771'       # Accent rouge
    ACCENT_PURPLE = '#c586c0'    # Accent violet
    BORDER = '#3e3e42'           # Bordures
    
    def __init__(self, root, installer_manager=None, config_manager=None):
        self.root = root
        self.installer_manager = installer_manager
        self.config_manager = config_manager
        self.logger = logging.getLogger(__name__)
        
        # Variables pour les programmes
        self.program_vars = {}
        self.programs = {}
        self.category_frames = {}
        self.category_widgets = {}
        self.collapsed_categories = set()
        self.is_installing = False
        
        # Charger TOUS les programmes
        self.load_all_programs()
        
        # Interface
        self.setup_window()
        self.setup_styles()
        self.create_main_interface()
        
        # Protocole de fermeture propre
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def setup_window(self):
        """Configure la fen√™tre principale en plein √©cran"""
        self.root.title("üöÄ NiTrite v.2 - Installateur Automatique de Programmes (80+ applications)")
        
        # MAXIMISER compl√®tement la fen√™tre
        self.root.state('zoomed')
        
        # Configuration responsive
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(0, weight=1)
        
        # Couleur de fond SOMBRE
        self.root.configure(bg=self.DARK_BG)
        
        # Ic√¥ne (si disponible)
        try:
            icon_path = Path(__file__).parent.parent / 'assets' / 'icon.ico'
            if icon_path.exists():
                self.root.iconbitmap(str(icon_path))
        except:
            pass
    
    def setup_styles(self):
        """Configure les styles pour mode sombre"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # Configuration globale MODE SOMBRE
        style.configure('.',
                       background=self.DARK_BG,
                       foreground=self.DARK_FG,
                       fieldbackground=self.DARK_BG2,
                       bordercolor=self.BORDER,
                       darkcolor=self.DARK_BG,
                       lightcolor=self.DARK_BG3)
        
        # Labels
        style.configure('TLabel',
                       background=self.DARK_BG,
                       foreground=self.DARK_FG)
        
        # Frames
        style.configure('TFrame',
                       background=self.DARK_BG)
        
        # LabelFrames
        style.configure('TLabelframe',
                       background=self.DARK_BG,
                       foreground=self.ACCENT_BLUE,
                       bordercolor=self.BORDER)
        style.configure('TLabelframe.Label',
                       background=self.DARK_BG,
                       foreground=self.ACCENT_BLUE,
                       font=('Segoe UI', 10, 'bold'))
        
        # Boutons
        style.configure('TButton',
                       background=self.DARK_BG2,
                       foreground=self.DARK_FG,
                       bordercolor=self.BORDER,
                       font=('Segoe UI', 9))
        style.map('TButton',
                 background=[('active', self.DARK_BG3), ('pressed', self.ACCENT_BLUE)],
                 foreground=[('active', self.DARK_FG)])
        
        # Checkbuttons
        style.configure('TCheckbutton',
                       background=self.DARK_BG,
                       foreground=self.DARK_FG,
                       font=('Segoe UI', 9))
        style.map('TCheckbutton',
                 background=[('active', self.DARK_BG)])
        
        # Styles sp√©cialis√©s
        style.configure('Title.TLabel', 
                       font=('Segoe UI', 16, 'bold'),
                       foreground=self.ACCENT_BLUE,
                       background=self.DARK_BG)
        
        style.configure('Category.TLabel', 
                       font=('Segoe UI', 11, 'bold'),
                       foreground=self.ACCENT_ORANGE,
                       background=self.DARK_BG)
        
        style.configure('Action.TButton', 
                       font=('Segoe UI', 11, 'bold'),
                       padding=8,
                       background=self.ACCENT_BLUE,
                       foreground='#ffffff')
        style.map('Action.TButton',
                 background=[('active', '#1177bb')])
        
        style.configure('Select.TButton', 
                       font=('Segoe UI', 9, 'bold'),
                       padding=4)
    
    def load_all_programs(self):
        """Charge TOUS les programmes depuis programs.json"""
        try:
            programs_file = Path(__file__).parent.parent / 'data' / 'programs.json'
            
            if programs_file.exists():
                with open(programs_file, 'r', encoding='utf-8') as f:
                    self.programs = json.load(f)
                
                # Compter le total
                total = sum(len(progs) if isinstance(progs, dict) else 0 
                          for progs in self.programs.values())
                
                self.logger.info(f"‚úÖ {total} programmes charg√©s depuis {len(self.programs)} cat√©gories")
                
            else:
                self.logger.warning("‚ö†Ô∏è Fichier programs.json non trouv√©")
                self.programs = {}
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors du chargement des programmes: {e}")
            self.programs = {}
    
    def create_main_interface(self):
        """Cr√©e l'interface principale"""
        # Frame principal MODE SOMBRE
        main_frame = ttk.Frame(self.root, padding="5")
        main_frame.grid(row=0, column=0, sticky="nsew")
        main_frame.grid_rowconfigure(2, weight=1)
        main_frame.grid_columnconfigure(0, weight=3)  # Colonne programmes
        main_frame.grid_columnconfigure(1, weight=1)  # Colonne outils
        
        # En-t√™te
        self.create_header(main_frame)
        
        # Barre d'actions (AVANT pour initialiser selection_label)
        self.create_action_bar(main_frame)
        
        # Zone principale des programmes (avec scrolling complet)
        self.create_programs_area(main_frame)
        
        # Panel d'outils √† droite (DISM, MAS, Param√®tres)
        self.create_tools_panel(main_frame)
    
    def create_header(self, parent):
        """Cr√©e l'en-t√™te"""
        header_frame = ttk.Frame(parent)
        header_frame.grid(row=0, column=0, sticky="ew", pady=(0, 5))
        
        # Calcul du nombre total de programmes
        total_programs = sum(len(progs) if isinstance(progs, dict) else 0 
                           for progs in self.programs.values())
        
        # Titre MODE SOMBRE
        title_label = ttk.Label(
            header_frame,
            text=f"üéØ NITRITE v.2 - {total_programs} APPLICATIONS",
            style='Title.TLabel'
        )
        title_label.pack()
        
        # Sous-titre MODE SOMBRE
        subtitle_label = ttk.Label(
            header_frame,
            text="Installation silencieuse ‚Ä¢ Sources officielles",
            font=('Segoe UI', 9),
            foreground=self.DARK_FG2,
            background=self.DARK_BG
        )
        subtitle_label.pack(pady=(2, 0))
    
    def create_programs_area(self, parent):
        """Cr√©e la zone des programmes avec TOUS les programmes affich√©s"""
        programs_frame = ttk.LabelFrame(parent, text="üìã PROGRAMMES", padding=3)
        programs_frame.grid(row=2, column=0, sticky="nsew")
        programs_frame.grid_rowconfigure(0, weight=1)
        programs_frame.grid_columnconfigure(0, weight=1)
        
        # Canvas principal avec scrollbar MODE SOMBRE
        self.main_canvas = tk.Canvas(
            programs_frame, 
            bg=self.DARK_BG,
            highlightthickness=0
        )
        
        main_scrollbar = ttk.Scrollbar(programs_frame, orient="vertical", command=self.main_canvas.yview)
        self.scrollable_frame = ttk.Frame(self.main_canvas)
        
        # Configuration du scroll
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.main_canvas.configure(scrollregion=self.main_canvas.bbox("all"))
        )
        
        self.main_canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw", width=1800)
        self.main_canvas.configure(yscrollcommand=main_scrollbar.set)
        
        # Placement
        self.main_canvas.grid(row=0, column=0, sticky="nsew")
        main_scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Bind scroll avec molette
        self.main_canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        
        # Cr√©er les checkboxes pour TOUS les programmes
        self.create_all_program_checkboxes()
        
        # Mettre √† jour le compteur initial
        if hasattr(self, 'selection_label'):
            self.update_selection_count()
    
    def safe_update_selection_count(self):
        """Version s√ªre de update_selection_count"""
        if hasattr(self, 'selection_label'):
            self.update_selection_count()
    
    def create_all_program_checkboxes(self):
        """Cr√©e les checkboxes pour TOUS les programmes par cat√©gorie"""
        row = 0
        
        # Ic√¥nes pour les cat√©gories
        category_icons = {
            'Navigateurs': 'üåê',
            'D√©veloppement': 'üíª',
            'Bureautique': 'üìù',
            'Multim√©dia': 'üé®',
            'Utilitaires': 'üîß',
            'Communication': 'üí¨',
            'Jeux': 'üéÆ',
            'S√©curit√©': 'üõ°Ô∏è',
            'Internet': 'üåç',
            'Outils OrdiPlus': 'üõ†Ô∏è',
            'Pack Office': 'üì¶'
        }
        
        # Ordre d'affichage des cat√©gories (OrdiPlus en premier)
        category_order = [
            'Outils OrdiPlus',
            'Pack Office',
            'Navigateurs',
            'Bureautique',
            'Multim√©dia',
            'D√©veloppement',
            'Utilitaires',
            'S√©curit√©',
            'Communication',
            'Jeux',
            'Internet'
        ]
        
        # Afficher dans l'ordre d√©fini
        sorted_categories = []
        for cat in category_order:
            if cat in self.programs and isinstance(self.programs[cat], dict) and len(self.programs[cat]) > 0:
                sorted_categories.append((cat, self.programs[cat]))
        
        # Ajouter les cat√©gories manquantes
        for category, programs in sorted(self.programs.items()):
            if category not in category_order and isinstance(programs, dict) and len(programs) > 0:
                sorted_categories.append((category, programs))
        
        for category, programs in sorted_categories:
            icon = category_icons.get(category, 'üì¶')
            
            # Titre de cat√©gorie avec bouton plier/d√©plier MODE SOMBRE
            category_header = ttk.Frame(self.scrollable_frame)
            category_header.grid(row=row, column=0, sticky="ew", pady=(8, 3), padx=5)
            category_header.grid_columnconfigure(1, weight=1)
            
            # Bouton plier/d√©plier
            collapse_btn = ttk.Button(
                category_header,
                text="‚ñº",
                width=3,
                command=lambda cat=category: self.toggle_category(cat)
            )
            collapse_btn.grid(row=0, column=0, padx=(0, 5))
            
            # Label de cat√©gorie MODE SOMBRE
            category_label = ttk.Label(
                category_header,
                text=f"{icon} {category.upper()} - {len(programs)} programmes",
                style='Category.TLabel',
                font=('Segoe UI', 11, 'bold')
            )
            category_label.grid(row=0, column=1, sticky="w")
            
            # Bouton s√©lectionner tout dans cette cat√©gorie
            select_cat_btn = ttk.Button(
                category_header,
                text="‚úì Tout",
                width=8,
                command=lambda c=category: self.select_category(c)
            )
            select_cat_btn.grid(row=0, column=2, padx=(5, 0))
            
            row += 1
            
            # Ligne de s√©paration MODE SOMBRE
            separator = ttk.Separator(self.scrollable_frame, orient='horizontal')
            separator.grid(row=row, column=0, sticky="ew", pady=(0, 3))
            row += 1
            
            # Frame pour les programmes de cette cat√©gorie MODE SOMBRE
            programs_container = ttk.Frame(self.scrollable_frame)
            programs_container.grid(row=row, column=0, sticky="ew", padx=15)
            
            # 5 COLONNES pour gagner de la place
            for i in range(5):
                programs_container.grid_columnconfigure(i, weight=1)
            
            # Stocker les widgets pour le plier/d√©plier
            self.category_widgets[category] = {
                'collapse_btn': collapse_btn,
                'programs_container': programs_container
            }
            
            # Programmes en 5 colonnes pour maximiser l'affichage
            prog_row = 0
            col = 0
            
            for program_name, program_info in sorted(programs.items()):
                # Frame pour ce programme (COMPACT)
                prog_frame = ttk.Frame(programs_container)
                prog_frame.grid(row=prog_row, column=col, sticky="w", padx=3, pady=2)
                
                # V√©rifier si c'est un d√©sinstallateur (cat√©gorie sp√©ciale)
                is_uninstaller = category == "D√©sinstallateurs Antivirus"
                
                if is_uninstaller:
                    # Pour les d√©sinstallateurs : bouton T√©l√©charger au lieu de checkbox
                    download_btn = ttk.Button(
                        prog_frame,
                        text=f"üì• {program_name}",
                        command=lambda url=program_info.get('download_url', ''): self.open_download_link(url),
                        width=30
                    )
                    download_btn.pack(anchor='w')
                    
                    # Description courte
                    desc = program_info.get('description', '')
                    if desc:
                        desc_label = ttk.Label(
                            prog_frame,
                            text=desc[:45] + "..." if len(desc) > 45 else desc,
                            font=('Segoe UI', 7),
                            foreground='#7f8c8d'
                        )
                        desc_label.pack(anchor='w', padx=(5, 0))
                else:
                    # Comportement normal : checkbox
                    var = tk.BooleanVar()
                    self.program_vars[program_name] = var
                    
                    # Checkbox avec nom du programme (POLICE PLUS PETITE)
                    checkbox = ttk.Checkbutton(
                        prog_frame,
                        text=program_name,
                        variable=var,
                        style='Program.TCheckbutton'
                    )
                    checkbox.pack(anchor='w')
                    
                    # Configurer la police plus petite
                    checkbox.configure(style='Program.TCheckbutton')
                    
                    # Lier manuellement le changement
                    var.trace_add('write', lambda *args: self.safe_update_selection_count())
                    
                    # Description (SI DISPONIBLE et COURTE)
                    desc = program_info.get('description', '')
                    if desc and len(desc) < 60:
                        desc_label = ttk.Label(
                            prog_frame,
                            text=desc[:40] + "..." if len(desc) > 40 else desc,
                            font=('Segoe UI', 7),
                            foreground='#7f8c8d'
                        )
                        desc_label.pack(anchor='w', padx=(20, 0))
                
                # Passer √† la colonne suivante
                col += 1
                if col >= 5:  # 5 colonnes
                    col = 0
                    prog_row += 1
            
            row += 1
    
    def toggle_category(self, category):
        """Plie ou d√©plie une cat√©gorie"""
        if category in self.category_widgets:
            widgets = self.category_widgets[category]
            
            if category in self.collapsed_categories:
                # D√©plier
                widgets['programs_container'].grid()
                widgets['collapse_btn'].config(text="‚ñº")
                self.collapsed_categories.remove(category)
            else:
                # Plier
                widgets['programs_container'].grid_remove()
                widgets['collapse_btn'].config(text="‚ñ∂")
                self.collapsed_categories.add(category)
            
            # Mettre √† jour la r√©gion de d√©filement
            self.scrollable_frame.update_idletasks()
            self.main_canvas.configure(scrollregion=self.main_canvas.bbox("all"))
    
    def create_action_bar(self, parent):
        """Cr√©e la barre d'actions"""
        action_frame = ttk.Frame(parent)
        action_frame.grid(row=1, column=0, sticky="ew", pady=(5, 0))
        action_frame.grid_columnconfigure(1, weight=1)
        
        # Label de s√©lection (PLUS COMPACT)
        self.selection_label = ttk.Label(
            action_frame,
            text="0 programme(s) s√©lectionn√©(s)",
            font=('Segoe UI', 11, 'bold'),
            foreground='#2c3e50'
        )
        self.selection_label.grid(row=0, column=0, sticky="w", padx=5)
        
        # Barre de progression (PLUS PETITE)
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            action_frame,
            variable=self.progress_var,
            maximum=100,
            length=250
        )
        self.progress_bar.grid(row=0, column=1, sticky="ew", padx=15)
        
        # Bouton d'installation (PLUS COMPACT)
        self.install_button = ttk.Button(
            action_frame,
            text="üöÄ INSTALLER",
            command=self.start_installation,
            style='Action.TButton',
            state='disabled'  # Initialement d√©sactiv√©
        )
        self.install_button.grid(row=0, column=2, sticky="e", padx=5)
    
    def _on_mousewheel(self, event):
        """Gestion du scroll avec la molette"""
        self.main_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
    def select_all_programs(self):
        """S√©lectionne TOUS les programmes"""
        for var in self.program_vars.values():
            var.set(True)
        self.update_selection_count()
    
    def deselect_all_programs(self):
        """D√©s√©lectionne tous les programmes"""
        for var in self.program_vars.values():
            var.set(False)
        self.update_selection_count()
    
    def select_category(self, category):
        """S√©lectionne tous les programmes d'une cat√©gorie"""
        if category in self.programs:
            for program_name in self.programs[category]:
                if program_name in self.program_vars:
                    self.program_vars[program_name].set(True)
        self.update_selection_count()
    
    def update_selection_count(self):
        """Met √† jour le compteur de s√©lection"""
        selected_count = sum(1 for var in self.program_vars.values() if var.get())
        total_count = len(self.program_vars)
        
        self.selection_label.config(
            text=f"{selected_count} programme(s) s√©lectionn√©(s) sur {total_count}"
        )
        
        # Activer/d√©sactiver le bouton
        if selected_count > 0:
            self.install_button.config(state='normal')
        else:
            self.install_button.config(state='disabled')
    
    def start_installation(self):
        """D√©marre l'installation ou l'ex√©cution de commandes"""
        selected_programs = [
            name for name, var in self.program_vars.items() if var.get()
        ]
        
        if not selected_programs:
            messagebox.showwarning("Aucune s√©lection", "Veuillez s√©lectionner au moins un programme ou commande.")
            return
        
        # S√©parer les commandes des programmes
        commands_to_run = []
        programs_to_install = []
        
        for prog_name in selected_programs:
            # Chercher le programme dans la base de donn√©es
            prog_info = None
            for category_progs in self.programs_db.values():
                if prog_name in category_progs:
                    prog_info = category_progs[prog_name]
                    break
            
            if prog_info and prog_info.get('is_command'):
                commands_to_run.append((prog_name, prog_info))
            else:
                programs_to_install.append(prog_name)
        
        # Ex√©cuter les commandes imm√©diatement
        if commands_to_run:
            self.execute_commands(commands_to_run)
        
        # Installer les programmes si n√©cessaire
        if programs_to_install:
            # Confirmation
            if messagebox.askyesno(
                "Confirmation d'installation",
                f"Installer {len(programs_to_install)} programme(s) ?\n\n"
                "L'installation sera automatique et silencieuse."
            ):
                self.logger.info(f"Installation lanc√©e pour {len(programs_to_install)} programmes")
                
                # D√©sactiver le bouton d'installation
                self.is_installing = True
                self.install_button.config(state='disabled', text="‚è≥ Installation...")
                
                # Lancer l'installation dans un thread s√©par√©
                if self.installer_manager:
                    install_thread = threading.Thread(
                        target=self.installer_manager.install_programs,
                        args=(
                            programs_to_install,
                            self.update_progress,
                            self.log_installation_message,
                            self.on_installation_finished
                        ),
                        daemon=True
                    )
                    install_thread.start()
                else:
                    messagebox.showerror(
                        "Erreur",
                        "Le gestionnaire d'installation n'est pas disponible!"
                    )
                    self.is_installing = False
                    self.install_button.config(state='normal', text="üöÄ INSTALLER")
        elif not commands_to_run:
            messagebox.showwarning("Aucune s√©lection", "Aucune action √† effectuer.")
    
    def execute_commands(self, commands_list):
        """Ex√©cute les commandes Windows s√©lectionn√©es"""
        import subprocess
        
        executed_count = 0
        failed_count = 0
        
        for prog_name, prog_info in commands_list:
            command = prog_info.get('command', '')
            admin_required = prog_info.get('admin_required', False)
            
            try:
                if admin_required:
                    # Ex√©cuter en mode administrateur avec PowerShell
                    ps_command = f'Start-Process cmd.exe -ArgumentList "/c {command}" -Verb RunAs'
                    subprocess.Popen(
                        ["powershell.exe", "-Command", ps_command],
                        shell=True,
                        creationflags=subprocess.CREATE_NO_WINDOW
                    )
                else:
                    # Ex√©cuter normalement
                    subprocess.Popen(
                        command,
                        shell=True,
                        creationflags=subprocess.CREATE_NO_WINDOW
                    )
                
                self.logger.info(f"‚úÖ Commande ex√©cut√©e: {prog_name}")
                executed_count += 1
                
            except Exception as e:
                self.logger.error(f"‚ùå Erreur lors de l'ex√©cution de {prog_name}: {e}")
                failed_count += 1
        
        # D√©s√©lectionner les commandes ex√©cut√©es
        for prog_name, _ in commands_list:
            if prog_name in self.program_vars:
                self.program_vars[prog_name].set(False)
        
        self.update_selection_count()
        
        # Message de r√©sultat
        if executed_count > 0:
            message = f"‚úÖ {executed_count} commande(s) ex√©cut√©e(s)"
            if failed_count > 0:
                message += f"\n‚ö†Ô∏è {failed_count} √©chec(s)"
            
            messagebox.showinfo("Commandes ex√©cut√©es", message)

    
    def update_progress(self, value, message=""):
        """Met √† jour la barre de progression"""
        self.progress_var.set(value)
        if message:
            self.selection_label.config(text=f"‚è≥ {message}")
        self.root.update_idletasks()
    
    def log_installation_message(self, message, level="info"):
        """Affiche un message de log"""
        print(f"[{level.upper()}] {message}")
        self.logger.info(message)
    
    def on_installation_finished(self, success):
        """Appel√© quand l'installation est termin√©e"""
        self.is_installing = False
        self.install_button.config(state='normal', text="üöÄ INSTALLER")
        
        if success:
            messagebox.showinfo(
                "Installation termin√©e",
                "‚úÖ L'installation de tous les programmes s√©lectionn√©s est termin√©e !\n\n"
                "V√©rifiez vos applications install√©es."
            )
            # Cr√©er le dossier "Outils de nettoyage" si n√©cessaire
            self.create_cleanup_folder()
            # D√©s√©lectionner tous les programmes
            self.deselect_all_programs()
        else:
            messagebox.showwarning(
                "Installation interrompue",
                "‚ö†Ô∏è L'installation a √©t√© interrompue.\n\n"
                "Certains programmes peuvent avoir √©t√© install√©s."
            )
        
        self.update_progress(0, "")
        self.update_selection_count()
    
    def create_cleanup_folder(self):
        """Cr√©e le dossier 'Outils de nettoyage' sur le bureau avec les raccourcis"""
        try:
            import os
            import winshell
            from win32com.client import Dispatch
            
            desktop = winshell.desktop()
            cleanup_folder = Path(desktop) / "Outils de nettoyage"
            cleanup_folder.mkdir(exist_ok=True)
            
            # Programmes √† inclure dans le dossier
            cleanup_programs = {
                "Malwarebytes": r"C:\Program Files\Malwarebytes\Anti-Malware\mbam.exe",
                "AdwCleaner": r"C:\Program Files\Malwarebytes\AdwCleaner\adwcleaner.exe",
                "Wise Disk Cleaner": r"C:\Program Files (x86)\Wise\Wise Disk Cleaner\WiseDiskCleaner.exe",
                "Spybot": r"C:\Program Files (x86)\Spybot - Search & Destroy 2\SDWelcome.exe"
            }
            
            # T√©l√©charger les portables
            portable_downloads = Path(__file__).parent.parent / "downloads"
            anydesk_exe = portable_downloads / "AnyDesk.exe"
            rustdesk_exe = portable_downloads / "rustdesk.exe"
            
            # Copier les ex√©cutables portables
            if anydesk_exe.exists():
                import shutil
                shutil.copy(anydesk_exe, cleanup_folder / "AnyDesk.exe")
            
            if rustdesk_exe.exists():
                import shutil
                shutil.copy(rustdesk_exe, cleanup_folder / "RustDesk.exe")
            
            # Cr√©er les raccourcis
            shell = Dispatch('WScript.Shell')
            
            for prog_name, exe_path in cleanup_programs.items():
                if Path(exe_path).exists():
                    shortcut_path = cleanup_folder / f"{prog_name}.lnk"
                    shortcut = shell.CreateShortCut(str(shortcut_path))
                    shortcut.Targetpath = exe_path
                    shortcut.WorkingDirectory = str(Path(exe_path).parent)
                    shortcut.IconLocation = exe_path
                    shortcut.save()
            
            self.logger.info(f"‚úÖ Dossier 'Outils de nettoyage' cr√©√© sur le bureau")
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Impossible de cr√©er le dossier Outils de nettoyage: {e}")
    
    def open_massgrave(self):
        """Ouvre le site MAS dans le navigateur"""
        import webbrowser
        webbrowser.open("https://massgrave.dev/")
        self.logger.info("üîê Ouverture du site MAS (Microsoft Activation Scripts)")
    
    def activate_windows(self):
        """Lance la commande d'activation Windows en admin"""
        if messagebox.askyesno(
            "Activation Windows",
            "‚ö° Cette commande va lancer le script d'activation Windows.\n\n"
            "Voulez-vous continuer ?\n\n"
            "Note: Un terminal PowerShell s'ouvrira avec les privil√®ges administrateur."
        ):
            try:
                import subprocess
                
                # Commande PowerShell √† ex√©cuter en admin
                command = 'irm https://get.activated.win | iex'
                
                # Lancer PowerShell en admin
                ps_command = f'Start-Process powershell -Verb RunAs -ArgumentList "-NoExit", "-Command", "{command}"'
                
                subprocess.run(
                    ['powershell', '-Command', ps_command],
                    shell=True
                )
                
                self.logger.info("‚ö° Commande d'activation Windows lanc√©e")
                messagebox.showinfo(
                    "Activation lanc√©e",
                    "‚úÖ Le script d'activation a √©t√© lanc√© !\n\n"
                    "Suivez les instructions dans la fen√™tre PowerShell."
                )
                
            except Exception as e:
                self.logger.error(f"‚ùå Erreur lors de l'activation: {e}")
                messagebox.showerror(
                    "Erreur",
                    f"‚ùå Impossible de lancer l'activation:\n{e}"
                )
    
    def create_tools_panel(self, parent):
        """Cr√©e le panel d'outils √† droite avec DISM, MAS et Param√®tres - REDIMENSIONNABLE"""
        tools_frame = ttk.LabelFrame(parent, text="üõ†Ô∏è OUTILS WINDOWS", padding=10)
        tools_frame.grid(row=2, column=1, sticky="nsew", padx=(10, 0))
        
        # Frame avec scroll pour les outils
        canvas = tk.Canvas(tools_frame, bg=self.DARK_BG2, highlightthickness=0)
        scrollbar = ttk.Scrollbar(tools_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Configuration des colonnes pour avoir 2 colonnes √©gales
        scrollable_frame.grid_columnconfigure(0, weight=1)
        scrollable_frame.grid_columnconfigure(1, weight=1)
        
        # Stocker pour permettre le drag & drop
        self.tools_scrollable_frame = scrollable_frame
        
        # Stocker pour permettre le drag & drop
        self.tools_scrollable_frame = scrollable_frame
        
        # === SECTION 1 : R√âPARATION SYST√àME (EN HAUT) ===
        dism_section = ttk.LabelFrame(scrollable_frame, text="üîß R√âPARATION SYST√àME", padding=5)
        dism_section.grid(row=0, column=0, columnspan=2, sticky="nsew", padx=5, pady=(0, 10))
        
        dism_buttons = [
            ("üîç DISM V√©rifier", "DISM /Online /Cleanup-Image /CheckHealth"),
            ("üîé DISM Scanner", "DISM /Online /Cleanup-Image /ScanHealth"),
            ("üîß DISM R√©parer", "DISM /Online /Cleanup-Image /RestoreHealth"),
            ("üßπ DISM Nettoyer", "DISM /Online /Cleanup-Image /StartComponentCleanup"),
            ("üßπ+ DISM Nettoyer++", "DISM /Online /Cleanup-Image /StartComponentCleanup /ResetBase"),
            ("üõ°Ô∏è SFC Scan", "sfc /scannow"),
            ("üíø ChkDsk C:", "chkdsk C: /F /R"),
            ("üíæ ChkDsk Scan", "chkdsk C: /scan"),
            ("üîÑ R√©parer Boot", "bootrec /fixmbr & bootrec /fixboot & bootrec /rebuildbcd"),
            ("üßº Nettoyer Store", "wsreset.exe"),
            ("üî• Vider DNS", "ipconfig /flushdns"),
            ("üåê Reset Winsock", "netsh winsock reset"),
            ("üì° Reset IP", "netsh int ip reset"),
            ("üî® DISM+SFC Complet", "DISM /Online /Cleanup-Image /RestoreHealth & sfc /scannow")
        ]
        
        for label, cmd in dism_buttons:
            ttk.Button(
                dism_section,
                text=label,
                command=lambda c=cmd: self.execute_quick_command(c, True),
                width=20
            ).pack(pady=1, fill="x")
        
        # === SECTION 2 : ACTIVATION (Ligne 1, Colonne 0) ===
        activation_section = ttk.LabelFrame(scrollable_frame, text="üîë ACTIVATION & T√âL√âCHARGEMENTS", padding=3)
        activation_section.grid(row=1, column=0, sticky="new", padx=5, pady=(0, 5))
        
        activation_frame = ttk.Frame(activation_section)
        activation_frame.pack(fill="x")
        
        ttk.Button(
            activation_frame,
            text="üîê MAS",
            command=self.open_massgrave,
            width=9
        ).grid(row=0, column=0, padx=1, pady=1, sticky="ew")
        
        ttk.Button(
            activation_frame,
            text="‚ö° Win",
            command=self.activate_windows,
            width=9
        ).grid(row=0, column=1, padx=1, pady=1, sticky="ew")
        
        # Ligne 2 : Office et YGG
        ttk.Button(
            activation_frame,
            text="üì¶ Office FR",
            command=lambda: self.open_manufacturer_support("https://gravesoft.dev/office_c2r_links#french-fr-fr"),
            width=9
        ).grid(row=1, column=0, padx=1, pady=1, sticky="ew")
        
        ttk.Button(
            activation_frame,
            text="üåä YGG",
            command=lambda: self.open_manufacturer_support("https://www.yggtorrent.top/auth/login"),
            width=9
        ).grid(row=1, column=1, padx=1, pady=1, sticky="ew")
        
        activation_frame.columnconfigure(0, weight=1)
        activation_frame.columnconfigure(1, weight=1)
        
        # === SECTION 3 : PARAM√àTRES WINDOWS (Ligne 1, Colonne 1) ===
        params_section = ttk.LabelFrame(scrollable_frame, text="‚öôÔ∏è PARAM√àTRES", padding=5)
        params_section.grid(row=1, column=1, sticky="nsew", padx=5, pady=(0, 10))
        
        params_buttons = [
            ("‚öôÔ∏è Param√®tres", "start ms-settings:"),
            ("üåê R√©seau", "start ms-settings:network"),
            ("üì° Bluetooth", "start ms-settings:bluetooth"),
            ("üñ®Ô∏è Imprimantes", "start ms-settings:printers"),
            ("üîä Son", "start ms-settings:sound"),
            ("‚å®Ô∏è Clavier", "start ms-settings:keyboard"),
            ("üîë Activation", "start ms-settings:activation"),
            ("üîÑ Update", "start ms-settings:windowsupdate"),
            ("üì± P√©riph√©riques", "start ms-settings:connecteddevices"),
            ("üéõÔ∏è Panneau", "control"),
            ("üì¶ Programmes", "appwiz.cpl"),
            ("‚öôÔ∏è Services", "services.msc"),
            ("üìù Registre", "regedit")
        ]
        
        for label, cmd in params_buttons:
            ttk.Button(
                params_section,
                text=label,
                command=lambda c=cmd: self.execute_quick_command(c, False),
                width=20
            ).pack(pady=1, fill="x")
        
        # Section R√©paration Windows (DISM) - Colonne 0, Ligne 1
        dism_section = ttk.LabelFrame(scrollable_frame, text="üîß R√âPARATION SYST√àME", padding=5)
        dism_section.grid(row=1, column=0, sticky="nsew", padx=5, pady=(0, 10))
        
        dism_buttons = [
            ("üîç DISM V√©rifier", "DISM /Online /Cleanup-Image /CheckHealth"),
            ("üîé DISM Scanner", "DISM /Online /Cleanup-Image /ScanHealth"),
            ("üîß DISM R√©parer", "DISM /Online /Cleanup-Image /RestoreHealth"),
            ("üßπ DISM Nettoyer", "DISM /Online /Cleanup-Image /StartComponentCleanup"),
            ("üßπ+ DISM Nettoyer++", "DISM /Online /Cleanup-Image /StartComponentCleanup /ResetBase"),
            ("üõ°Ô∏è SFC Scan", "sfc /scannow"),
            ("üíø ChkDsk C:", "chkdsk C: /F /R"),
            ("üíæ ChkDsk Scan", "chkdsk C: /scan"),
            ("üîÑ R√©parer Boot", "bootrec /fixmbr & bootrec /fixboot & bootrec /rebuildbcd"),
            ("üßº Nettoyer Store", "wsreset.exe"),
            ("üî• Vider DNS", "ipconfig /flushdns"),
            ("üåê Reset Winsock", "netsh winsock reset"),
            ("ÔøΩ Reset IP", "netsh int ip reset"),
            ("ÔøΩüî® DISM+SFC Complet", "DISM /Online /Cleanup-Image /RestoreHealth & sfc /scannow")
        ]
        
        for label, cmd in dism_buttons:
            ttk.Button(
                dism_section,
                text=label,
                command=lambda c=cmd: self.execute_quick_command(c, True),
                width=20
            ).pack(pady=1, fill="x")
        
        # Section Support Fabricants - Colonne 1, Ligne 1
        support_section = ttk.LabelFrame(scrollable_frame, text="üè¢ SUPPORT & DRIVERS", padding=5)
        support_section.grid(row=1, column=1, sticky="nsew", padx=5, pady=(0, 10))
        
        support_buttons = [
            ("üñ®Ô∏è HP", "https://support.hp.com/fr-fr/help/hp-support-assistant"),
            ("üíª Dell", "https://www.dell.com/support/home/fr-fr/product-support/product/supportassist-for-home-pcs/download"),
            ("üéÆ MSI", "https://fr.msi.com/Landing/MSI-Center"),
            ("‚ö° ASUS", "https://www.asus.com/fr/support/download-center/"),
            ("üîß Lenovo", "https://support.lenovo.com/fr/fr/solutions/ht505081"),
            ("üñ•Ô∏è Acer", "https://www.acer.com/fr-fr/support"),
            ("üíæ Intel", "https://www.intel.fr/content/www/fr/fr/support/detect.html"),
            ("üéÆ AMD", "https://www.amd.com/fr/support"),
            ("üñ•Ô∏è NVIDIA", "https://www.nvidia.com/fr-fr/geforce/geforce-experience/"),
            ("üì± Samsung", "https://www.samsung.com/fr/support/computing/samsung-magician/"),
            ("üîå Logitech", "https://www.logitechg.com/fr-fr/innovation/g-hub.html"),
            ("üñ±Ô∏è Razer", "https://www.razer.com/fr-fr/synapse-3")
        ]
        
        for label, url in support_buttons:
            ttk.Button(
                support_section,
                text=label,
                command=lambda u=url: self.open_manufacturer_support(u),
                width=20
            ).pack(pady=1, fill="x")
    
    def open_manufacturer_support(self, url):
        """Ouvre le lien de support du fabricant dans le navigateur"""
        import webbrowser
        try:
            webbrowser.open(url)
            self.logger.info(f"‚úÖ Ouverture du support fabricant: {url}")
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de l'ouverture du lien: {e}")
            messagebox.showerror(
                "Erreur",
                f"‚ùå Impossible d'ouvrir le lien:\n{e}"
            )
    
    def open_download_link(self, url):
        """Ouvre le lien de t√©l√©chargement dans le navigateur"""
        import webbrowser
        try:
            if url:
                webbrowser.open(url)
                self.logger.info(f"‚úÖ Ouverture du lien de t√©l√©chargement: {url}")
                messagebox.showinfo(
                    "T√©l√©chargement",
                    "Le lien de t√©l√©chargement a √©t√© ouvert dans votre navigateur.\n\n"
                    "T√©l√©chargez l'outil et ex√©cutez-le pour d√©sinstaller proprement l'antivirus."
                )
            else:
                messagebox.showerror(
                    "Erreur",
                    "Aucun lien de t√©l√©chargement disponible pour cet outil."
                )
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de l'ouverture du lien: {e}")
            messagebox.showerror(
                "Erreur",
                f"‚ùå Impossible d'ouvrir le lien:\n{e}"
            )
    
    def execute_quick_command(self, command, admin_required=False):
        """Ex√©cute une commande Windows rapidement (boutons d'acc√®s rapide)"""
        import subprocess
        
        try:
            if admin_required:
                # Confirmation pour les commandes admin
                if not messagebox.askyesno(
                    "Droits administrateur requis",
                    f"Cette commande n√©cessite les droits administrateur:\n\n{command}\n\n"
                    "Voulez-vous continuer ?"
                ):
                    return
                
                # Ex√©cuter en mode administrateur avec PowerShell - FEN√äTRE VISIBLE
                ps_command = f'Start-Process cmd.exe -ArgumentList "/k {command}" -Verb RunAs'
                subprocess.Popen(
                    ["powershell.exe", "-Command", ps_command],
                    shell=True
                )
                self.logger.info(f"‚úÖ Commande admin ex√©cut√©e: {command}")
                
            else:
                # Ex√©cuter normalement - FEN√äTRE VISIBLE
                subprocess.Popen(
                    ["cmd.exe", "/k", command],
                    shell=True
                )
                self.logger.info(f"‚úÖ Commande ex√©cut√©e: {command}")
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de l'ex√©cution de la commande: {e}")
            messagebox.showerror(
                "Erreur",
                f"‚ùå Impossible d'ex√©cuter la commande:\n{e}"
            )
    
    def on_closing(self):
        """Fermeture propre de l'application"""
        import sys
        import gc
        
        try:
            # Arr√™ter toute installation en cours
            if self.is_installing:
                if not messagebox.askyesno(
                    "Installation en cours",
                    "Une installation est en cours. Voulez-vous vraiment quitter ?"
                ):
                    return
            
            # Fermer tous les logs
            logging.shutdown()
            
            # Nettoyer les r√©f√©rences
            self.program_vars.clear()
            self.programs.clear()
            self.category_frames.clear()
            self.category_widgets.clear()
            
            # Forcer le garbage collector
            gc.collect()
            
            # D√©truire la fen√™tre
            self.root.quit()
            self.root.destroy()
            
            # Forcer la sortie
            sys.exit(0)
            
        except Exception as e:
            print(f"Erreur lors de la fermeture: {e}")
            sys.exit(0)


def create_gui_manager(root, installer_manager=None, config_manager=None):
    """Cr√©e et retourne le GUI Manager complet"""
    return NiTriteGUIComplet(root, installer_manager, config_manager)
